using Microsoft.Build.Framework;
using Microsoft.Build.Logging;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Text;

namespace Sandbox103.V2;

/// <summary>
/// Reads <c>.binlog</c> files generated by MSBuild and caches
/// computed statistics about each build and/or its archived files.
/// </summary>
internal sealed class BinaryLogReader : IBinaryLogReader
{
    private readonly ILogger<BinaryLogReader> _logger;
    private readonly IArchiveFileIndex _archiveFileIndex;
    private readonly IReadOnlyList<IEventSourceSubscriber> _subscribers;

    public BinaryLogReader(
        ILogger<BinaryLogReader> logger,
        IArchiveFileIndex archiveFileIndex,
        IEnumerable<IEventSourceSubscriber> subscribers)
    {
        ArgumentNullException.ThrowIfNull(logger);
        ArgumentNullException.ThrowIfNull(archiveFileIndex);
        ArgumentNullException.ThrowIfNull(subscribers);

        _logger = logger;
        _archiveFileIndex = archiveFileIndex;
        _subscribers = subscribers.ToArray();
    }

    /// <inheritdoc/>
    public async Task<IBinaryLog> ReadAsync(BinaryLogReaderOptions options, CancellationToken cancellationToken)
    {
        ThrowHelper.ThrowIfFileNotFound(options.Path);
        cancellationToken.ThrowIfCancellationRequested();

        // Read and cache all of the archive file content. This is about 10MB for XSU builds.
        // It consists of the .props and .targets files used in the build.
        IArchiveFile projectFile = await PreReadAsync(options.Path, cancellationToken);

        if (_subscribers.Count > 0)
        {
            using var logScope = _logger.BeginScope("{0} - {1}", nameof(ReadAsync), options.Path);
            long t0 = Stopwatch.GetTimestamp();
            _logger.LogInformation($"Binary log event replay starting.");

            var eventSource = new BinaryLogReplayEventSource() { AllowForwardCompatibility = true };
            eventSource.RecoverableReadError += _ => { };

            foreach (IEventSourceSubscriber subscriber in _subscribers)
            {
                subscriber.EventSourceCreated(eventSource, projectFile);
            }

            eventSource.Replay(options.Path, cancellationToken);
            eventSource.Dispatch(new EventSourceStopped());

            _logger.LogInformation($"Binary log event replay finished. {Stopwatch.GetElapsedTime(t0)}");
        }

        return new BinaryLog(options.Path, projectFile);
    }

    /// <summary>
    /// Read all archive files into the index; return the root project built in the binary log.
    /// </summary>
    /// <param name="path">Path to the <c>.binlog</c> file.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The root project built in the binary log.</returns>
    private Task<IArchiveFile> PreReadAsync(string path, CancellationToken cancellationToken)
    {
        ThrowHelper.ThrowIfFileNotFound(path);
        cancellationToken.ThrowIfCancellationRequested();

        using var loggerScope = _logger.BeginScope("{0}: {1}", nameof(PreReadAsync), path);
        _logger.LogInformation($"Reading archive files from binlog file.");
        int count = 0;
        string? firstProjectFile = null;
        string? firstBuildProjectFile = null;
        long t0 = Stopwatch.GetTimestamp();

        var eventSource = new BinaryLogReplayEventSource() { AllowForwardCompatibility = true };
        IBuildEventArgsReaderNotifications notifications = eventSource;
        notifications.RecoverableReadError += _ => { }; // mandatory with forward compatibility
        notifications.ArchiveFileEncountered += ArchiveFileEncountered;
        eventSource.ProjectStarted += ProjectStarted;
        eventSource.AnyEventRaised += ProjectEvaluationStarted;

        eventSource.Replay(path, cancellationToken);

        _logger.LogInformation($"Finished reading the binlog. Found {count} new archive file(s). ({Stopwatch.GetElapsedTime(t0)})");

        string rootProjectFile = firstBuildProjectFile ?? firstProjectFile ??
            throw new InvalidOperationException($"Unexpected error: unable to determine the project built in the binlog file '{path}'.");

        if (!_archiveFileIndex.TryGetValue(rootProjectFile, out IArchiveFile? rootProjectArchiveFile))
        {
            throw new InvalidOperationException($"Unexpected error: archive file missing for project '{rootProjectFile}'.");
        }

        return Task.FromResult(rootProjectArchiveFile);

        void ProjectEvaluationStarted(object? sender, BuildEventArgs e)
        {
            if (e is not ProjectEvaluationStartedEventArgs args) return;

            if (args.ProjectFile is string projectFile)
            {
                firstProjectFile ??= projectFile;
            }
        }

        void ProjectStarted(object? sender, ProjectStartedEventArgs args)
        {
            if (args.ProjectFile is string projectFile &&
                !string.IsNullOrEmpty(projectFile) &&
                string.Equals(args.SenderName, "MSBuild", StringComparison.OrdinalIgnoreCase) &&
                (string.Equals(args.TargetNames, "Build", StringComparison.OrdinalIgnoreCase) ||
                (args.TargetNames?.Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)?.ToHashSet(StringComparer.OrdinalIgnoreCase)?.Contains("Build") is true)))
            {
                firstBuildProjectFile ??= projectFile;
            }
        }

        void ArchiveFileEncountered(ArchiveFileEventArgs args)
        {
            if (args.ArchiveData is not ArchiveData archiveData ||
                archiveData.FullPath is not string fullPath)
            {
                return;
            }

            static byte[] Buffer(ArchiveData archiveData)
            {
                // Do it like this for consistent encoding.
                // Could check if it's a StreamReader with UTF8 already, but it doesn't really matter.
                return Encoding.UTF8.GetBytes(archiveData.ToArchiveFile().Content);
            }

            IArchiveFile? archiveFileToAdd = null;

            while (!_archiveFileIndex.TryGetValue(fullPath, out _))
            {
                if (_archiveFileIndex.TryAdd(fullPath, archiveFileToAdd ??= new EmbeddedArchiveFile(fullPath, Buffer(archiveData))))
                {
                    Interlocked.Increment(ref count);
                    break;
                }
            }
        }
    }
}
